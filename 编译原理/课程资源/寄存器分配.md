**CDCL**通过冲突分析和学习新约束，智能避免无效搜索路径，从而比传统DPLL算法更高效地解决SAT问题

![image-20250618155536921](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250618155536921.png)



#### 一阶逻辑（First-Order Logic, FOL）

**定义组成：**

1. **对象符号（Symbols for objects）**
    例如：𝑎、𝑏、𝑐等，用于表示具体的对象。

2. **N元谓词（N-ary Predicates）**
    表示关系，返回真或假，例如 p(t1,t2,...,tn)，判断对象间的某种关系是否成立。

3. **N元函数（N-ary Functions）**
    表示从对象到对象的映射，例如 f(t1,t2,...,tn)，计算结果仍是对象。

4. **公式（Formulas）**
    公式可以是：

   常量真（⊤）或假（⊥）项 t 否定（¬F）合取（F1 ∧ F2）析取（F1 ∨ F2）蕴含（F1 ⇒ F2）等价（F1 ⇔ F2）全称量化（∀x. F）存在量化（∃x. F）

 **Satisfiability Modulo Theories (SMT)** 中 **基于位向量理论** 的核心步骤

For the theory of bit vectors
Step 1: Word-Level Preprocessing 
Step 2: Bit-Blasting (From FOL to PL) 
Step 3: DPLL/CDCL

step1：
x=[a0,a1,…,a7] y=[b0,b1,…,b7] z=[c0,c1,…,c7]
step2：位爆破
将高层次的位向量操作拆解成针对每一位的布尔变量及布尔公式。
对位或操作 x∣y=z展开成
(a0∨b0)⟺c0,(a1∨b1)⟺c1,…,(a7∨b7)⟺c7
step3
SAT求解（DPLL/CDCL）

**Pointer Analysis**

判断程序中**两个指针变量是否可能指向同一块内存地址（即存在别名）**。

为什么重要？

因为当两个指针可能指向相同位置时，修改一个指针所指的数据可能会影响另一个。
 这会影响编译器对程序的优化，比如：消除冗余加载（load）指令重排序死代码消除

| 分析类型   | 判断标准                         | 特点                                 | 作用场景               |
| ---------- | -------------------------------- | ------------------------------------ | ---------------------- |
| May Alias  | 两个表达式 **可能** 指向同一地址 | **保守**，**不漏报**，但**可能多报** | 用于判断“是否不能别名” |
| Must Alias | 两个表达式 **一定** 指向同一地址 | **严格**，结果可信，可能漏报         | 用于激进优化和等价替代 |

**Flow-Sensitive Pointer Analysis**：**流敏感（Flow-Sensitive）指针分析** 是一种更精细的分析方式，它会考虑程序中指针值随执行流程的不同而发生的变化：在程序的每个位置（program point）都精确地分析指针当前可能指向哪些内存位置。

**流不敏感（Flow-Insensitive）指针分析** 是一种不考虑程序中执行顺序的分析方法：它将所有的赋值、引用等操作看成是“无序的”，统一考虑。也就是说，它只关注“哪些变量可能指向哪些内存位置”，但**不关心**“在哪一步”发生的这些操作

Andersen’s Algorithm

| 语句     | 约束关系                                                     | 解释                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------- |
| `y=& x`  | `pts(y) ⊇ {x}`                                               | `y` 至少指向 `x`                                  |
| `y = x`  | `pts(y) ⊇ pts(x)`                                            | `y` 指向的集合包含 `x` 指向的所有对象             |
| `*y = x` | 对 `v ∈ pts(y)` 有 `pts(v) ⊇ pts(x)`，并且 `pts(*y) ⊇ pts(x)` | 通过 `y` 间接存储，将 `x` 的指向集合传给 `pts(v)` |
| `y = *x` | 对 `v ∈ pts(x)` 有 `pts(y) ⊇ pts(v)`，并且 `pts(y) ⊇ pts(*x)` | 通过 `x` 间接读取，将 `pts(v)` 赋给 `pts(y)`      |

Steensgaard’s Algorithm

| 语句     | 约束关系                                                     | 解释                               |
| -------- | ------------------------------------------------------------ | ---------------------------------- |
| `y = &x` | `pts(y) ⊇ {x}`                                               | 与 Andersen 算法相同，`y` 指向 `x` |
| `y = x`  | `pts(y) = pts(x)`                                            | `y` 和 `x` 指向同一个集合          |
| `*y = x` | 对 `v ∈ pts(y)` 有 `pts(v) = pts(x)`，并且 `pts(*y) = pts(x)` | 间接赋值时将两个指针集合合并       |
| `y = *x` | 对 `v ∈ pts(x)` 有 `pts(y) = pts(v)`，并且 `pts(y) = pts(*x)` | 间接读取时将两个指针集合合并       |

| 特性       | Andersen 算法        | Steensgaard 算法         |
| ---------- | -------------------- | ------------------------ |
| 约束类型   | 包含关系（⊇）        | 相等关系（=）            |
| 结果精确度 | 精确（但仍为过约束） | 不精确，合并造成更大误差 |
| 复杂度     | 较高，近乎立方复杂度 | 低，接近线性复杂度       |
| 应用场景   | 对精度要求较高的场景 | 需要快速分析的场景       |

![image-20250618170037687](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250618170037687.png)



### **寄存器分配**

一种常用的 spill 策略，即“选择下次使用最远的变量”进行 spill。

Chaitin’s algorithm

局部寄存器分配法：

全局寄存器分配法：

K-coloring：1个节点的度数若小于K则他一定可以被成功染色

1.构建干涉图，如果两个变量的生命周期有重叠，就连一条线

2.移去度数小于K的点至栈中，直至图空

3.当每个节点的度数都大于K时，选择一个节点立即溢出，把它放置spilllist，并从图中溢出这个节点

4.继续2或3

5.如果spill list不空，重新构建冲突图，插入溢出码，其实就是把它溢出的位置存在的声明周期去掉



为什么要进行指令调度

现代高性能处理器（如 x86、ARM、RISC-V 的 superscalar 架构）可以在**一个时钟周期里执行多条指令**

硬件只能调度它“已经取指”的指令编译器知道程序的所有指令、依赖关系 硬件缓冲等待的空间有限

可以在编译时就安排好：把“互不依赖的指令”放在一起，让硬件并行执行 

寄存器分配的目的：
是在有限数量的硬件寄存器中，**分配变量或中间结果的存储位置**，以减少访问内存的频率，从而提高执行效率。具体作用如下：

1. **提高性能**：寄存器访问比内存快很多（几个周期 vs 数十个周期）
2. **减少指令数**：省去多次 `LD` / `ST` 的开销
3. **降低内存使用**：避免中间值反复写回内存
4. **支撑编译优化**：如寄存器重命名、调度等需要寄存器支持