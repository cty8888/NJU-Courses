## 实验输入

- 本次实验保证输入的正确性，且

  语法限制和 Lab5 相同

  。输入的 SysY 程序只包含以下语法：

  - main 函数和表达式
  - 局部变量和全局变量
  - 简单控制流（无 `&&` 和 `||` 运算符）

- 你的 java 程序需要接收两个参数：

  - args[0] 输入文件(sysy)的路径
  - args[1] 输出文件(ll)的路径

## 实验内容

本实验基于 Lab4 中生成的 LLVM IR 进行优化。

本次实验分为 3 个部分。完成一个部分会通过对应的用例。

## Part1 常量传播

Part1 需要你读取一个SysY 程序，生成对应的LLVM IR之后，进行常量传播优化。

**常量传播**（**Constant Propagation**）是一种经典的数据流分析，它可以将每次运行时总是得到相同常量值的表达式替换为该常量值。

例如：`int n = 1; return n;` → `return 1;`

正式开始本部分实验前，你需要首先复习理论课上学过的**数据流分析框架**、**WorkList算法**以及**常量传播算法**。以下为算法伪代码，供参考：

- 常量传播的数据流值：

  - `UNDEF`: 未初始化
  - `CONST(c)`: 常量 `c`
  - `NAC` : Not a Constant

- 算法伪代码：

  ```
  Initialize:
    for all blocks B:
      in[B] ← UNDEF
      out[B] ← UNDEF
    worklist ← all blocks
  
  While worklist not empty:
    B ← remove from worklist
    old_out ← out[B]
  
    in[B] ← meet{ out[P] | P ∈ predecessors[B] }
    out[B] ← transfer(B, in[B])
  
    if out[B] != old_out:
      add all successors of B to worklist
  ```

  ```
  function meet(x, y):
    if x == y: return x
    if x == UNDEF: return y
    if y == UNDEF: return x
    return NAC
  ```

  ```
  function transfer(B, in_vals):
    vals ← copy of in_vals
  
    for stmt in B:
      match stmt:
        case v = n:
        	if n is const:
            vals[v] ← const(n)
  
        case v = x op y:
          vx ← vals[x]
          vy ← vals[y]
  
          if vx and vy are both const:
            vals[v] ← evaluate(vx op vy)
          else if vx == NAC or vy == NAC:
            vals[v] ← NAC
          else:
            vals[v] ← UNDEF
         
         ...
  		
    return vals
  ```

在本次实验中，我们需要完成的常量传播分析与课程中介绍的稍有区别：为了简单起见，以**单条语句为基本单位**进行 transfer 操作，而不是基本块。这样做的另一个好处是可以获得更加精细的分析结果。

具体地，你需要按照如下步骤完成实验：

1. 构建控制流图（CFG）并分析每条语句的**前驱**（**predecessors**）和**后继**（**successors**）语句。
2. 初始化每条语句的 **in[S] 和 out[S]** 为 UNDEF，并把所有语句加入worklist。
3. 执行常量传播算法，直到不动点。
4. 遍历所有语句，如果语句的左值（LValue）是一个常量，则**使用 `LLVMReplaceAllUsesWith` 将所有该左值的使用点都替换为该常量值本身，然后使用 `LLVMInstructionEraseFromParent` 删除这条语句**。

注意：在本次实验中，**只被赋值一次的全局变量在使用时视为常量**。

如果你正确完成了 Part1 你将会通过 OJ 上的 constprop 测试。

### 样例

输入：

```
int global_var = 1;

int main() {
    int num = 1;
    int c = num;
    
    return num * num + c;
}
```

输出：

```
; ModuleID = 'module'
source_filename = "module"

@global_var = global i32 1

define i32 @main() {
mainEntry:
  %num = alloca i32, align 4
  store i32 1, i32* %num, align 4
  %c = alloca i32, align 4
  store i32 1, i32* %c, align 4
  ret i32 2
}
```

说明：常量传播直接得到最终返回值2，而无需对 `%num` 和 `%c` 做额外计算。

## Part2 未使用变量消除

Part2 需要你识别LLVM IR中的未使用变量并消除，生成优化后的LLVM IR。

**未使用变量（unused variable）\**为只定义而未被使用的\**局部变量**。你需要统计变量的定义和使用次数，识别未使用变量并消除它们。特别地，**全局变量不应该被消除**，哪怕它们未被使用！

如果你正确完成了 Part2 你将会通过 OJ 上的 unused 测试。

### 样例

输入：

```
int global_var = 1;

int main() {
    int num = 1;
    int c = num;
    
    return num * num + c;
}
```

输出：

```
; ModuleID = 'module'
source_filename = "module"

@global_var = global i32 1

define i32 @main() {
mainEntry:
  ret i32 2
}
```

说明：`%num` 和 `%c` 都是未使用变量。

## Part3: 死代码消除

去除死代码可以在不影响程序输出的情况下简化程序和提高效率。本部分需要你消除分支不可达代码，并综合之前的优化实现一个功能更强的IR优化器。

### 分支不可达代码消除

分支不可达代码是指由于控制流条件的确定性，某些永远不会被执行的代码。如对于 `br i1 true, label %true, label %false`，`%false`基本块就是不可达的。

**删除分支不可达代码**的简单流程：

1. 遍历控制流图，找到所有没有前驱的基本块，并使用 `LLVMRemoveBasicBlockFromParent` 将它们删除。每次删除基本块后，你都需要递归地检查是否出现了新的不可达基本块并删除它们。
2. 使用 **Part1 常量传播** 的结果，检查每个条件分支指令（`br i1 %cond, label %true, label %false`）的 `%cond`，如果 `%cond` 是常量，则标记不可达的基本块。
3. 更新跳转指令为无条件跳转，删除不可达基本块，更新控制流图。

此时，你的代码中很可能有冗余的跳转指令，你需要一并消除它们：

- 如果某个基本块的出口指令是 `br label %target`，且 `target` 块只有一个前驱，且该前驱不是自己，那么该跳转就是一个**冗余跳转**。你需要删除该跳转指令，并且将 `target` 的全部指令复制到该基本块后面，然后删除 `target` 块。

### 迭代优化

目前，你已经实现了三种 IR 优化：**常量传播**、**未使用变量消除** 和 **死代码消除**。你可能会发现，这些优化之间存在依赖关系，单独运行每个优化可能无法充分利用所有的优化机会。例如：

- **常量传播** 可能将条件分支的条件简化为常量，从而为 **死代码消除** 创造机会。
- **死代码消除** 可能移除不可达块或合并冗余跳转，导致某些变量不再被使用，为 **未使用变量消除** 创造机会。
- **未使用变量消除** 和 **死代码消除** 可能移除无用指令，进一步简化 IR，为 **常量传播** 创造机会。

为了最大化优化效果，你需要对于 LLVM IR 进行迭代优化，不断地交替应用三种 IR 优化策略，直到三种优化都无法使 LLVM IR 发生变化为止。（到达不动点）

如果你正确完成了 Part3 你将会通过 OJ 上的 deadcode 和 mix 测试。至此，你已完成了本次实验的全部内容。

### 样例

输入：

```
int global_var = 1;

int main() {
    int num = 1;
    int c = num;

    int i = 0;
    if (i > c) {
        num = num + 1;
        i = i + 1;
    } else {
        num = num + 1;
        i = i + 1;
    }

    return num * num + c;
}
```

输出：

```
; ModuleID = 'module'
source_filename = "module"

@global_var = global i32 1

define i32 @main() {
mainEntry:
  ret i32 5
}
```

说明：交替使用常量传播、死代码消除和未使用变量消除两轮后，无法再继续优化。

# Lab6 实验指导

## 如何管理多个优化？

每个优化作为独立模块（Pass），通过统一接口交互，如使用 `LLVMModuleRef run(LLVMModuleRef module);` 作为运行一次优化的接口。

## 如何构建CFG?

首先获取每个block的最后一条指令（使用 `LLVMGetBasicBlockTerminator(bb)` ），如果是一个跳转指令，则在跳转的起始基本块和目标基本块之间连接一条有向边。

## 遍历指令的同时如何删除指令?

采用延迟删除。收集需要删除的指令列表，遍历完后统一删除。

## 如何复制指令到另一个基本块?

LLVM Java API 似乎不能够直接完成该任务（如果你发现其实可以，请你务必告诉我们>_<）...

方便起见，助教编写了简易工具类 `InstrBuilderHelper`，你可以在[这里](https://git.nju.edu.cn/chaos-w/instrbuilderhelper/-/blob/main/InstrBuilderHelper.java?ref_type=heads)获取它并用于你的项目。

用法：

```
InstrBuildHelper buildHelper = new InstrBuildHelper();
LLVMBuilderRef builder = LLVMCreateBuilder();

LLVMPositionBuilderAtEnd(builder, bb);
buildHelper.buildInstruction(builder, inst); // 写入指令inst到基本块bb
```

## 需要了解的API

1. `LLVMReplaceAllUsesWith(old, new)`

   替换所有 `old` 为 `new`

   例子:

   ```
   LLVMValueRef constInst = LLVMConstInt(LLVMTypeOf(inst), constVal, 0); // 构建一个和inst相同类型的常量
   LLVMReplaceAllUsesWith(inst, constInst); // 替换所有用到inst的地方为constInst
   ```

2. `LLVMRemoveBasicBlockFromParent(bb)`

   删除基本块 `bb`

3. `LLVMInstructionEraseFromParent(inst)`

   删除指令 `inst`

4. `LLVMConstInt(type, val, sext)`

   创建类型为 `type`, 值为 `val`, 是否符号扩展为 `sext` 的常量